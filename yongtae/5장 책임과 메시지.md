## 5장 책임과 메시지

### 1. 자율적인 책임

명확한 책임과 역할을 지닌 객체들이 협력에 참여해야 한다.

훌륭한 객체지향의 세계는 명확하게 정의된 역할과 책임을 지닌 객체들이 상호 협력하는 세계

객체지향 설계의 아름다움은 적절한 책임을 적절한 객체에게 할당하는 과정 속에서 드러난다.

책임-주도 설계는 적절한 책임의 선택이 전체 설계의 방향을 결정하는 가장 널리 알려진 객체지향 설계 방법이다.

적절한 책임 -> 자율적인 객체 -> 유연하고 단순한 협력

따라서 협력에 참여하는 객체가 얼마나 자율적인지가 전체 어플리케이션의 품질을 결정

객체에게 할당되는 책임이 자율적이어야 객체가 자율적으로 책임을 수행할 수 있다.

너무 구체적인 책임을 할당하는 것도 문제이지만 너무 포괄적이고 추상적인 책임이 좋은 것도 아니다.

추상적이고 포괄적인 책임은 재사용성과 유연성을 확보하지만 협력에 참여하는 의도를 설명할 수 있는 수준에서 추상적이어야 한다.

어떤 책임이 가장 적절한가는 설계 중인 협력이 무엇인가에 따라 달라진다.

자율적인 책임의 특징 : 어떻게(how)가 아니라 무엇(what)을 해야 하는가를 설명

### 2. 메시지와 메서드

메시지는 객체로 하여금 자신의 책임을 수행하게 만드는 유일한 방법이다.

메시지는 메시지 이름과 인자의 두 부분으로 구성된다.

메시지 전송은 수신자, 메시지 이름, 인자의 조합이다.

객체가 수신할 수 있는 메시지의 모양이 객체가 수행할 책임의 모양을 결정한다.

객체의 외부와 내부는 메시지를 기준으로 분리된다.

객체가 제공하는 메시지 - 객체의 외부

책임을 수행하는 방법 – 객체의 내부

메서드 : 객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법

서로 다른 객체들이 다형성을 만족시키다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미

다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미

송신자가 수신자에 대해 적은 정보만을 알고 있어도 상호 협력이 가능하다는 사실은 유연하고 확장 가능하고 재사용성이 높은 협력을 의미한다.

객체지향 어플리케이션은 클래스를 사용해 만들어지지만 메시지를 통해 정의된다.

클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구.

클래스나 개별적인 객체를 중심에 두지 말고 메시지와 협력에 중심을 두고 설계해야 한다.

책임-주도 설계 simple steps

1.	시스템이 수행할 책임을 구현하기 위해 협력 관계를 시작할 적절한 객체 식별.

2.	객체가 책임을 수행하기 위해 다른 객체들과 협력이 필요하면 그 메시지를 결정

3.	메시지를 수신하기 적합한 객체를 선택

결과적으로 메시지가 수신자의 책임을 결정한다.

What/Who 사이클

어떤 행위(What, 메시지)를 수행할 것인지를 결정한 후에 누가(Who) 그 행위를 수행할 것인지를 결정

행위를 먼저 식별한 후에 행위를 수행할 적절한 객체를 찾는다.

책임-주도 설계의 핵심 아이디어는 역할을 수행할 객체의 인터페이스를 발견하기 위해 메시지를 이용

메시지를 결정하기 전까지는 객체에 대해 고민하지 말기! 그러면 수신자의 캡슐화를 증진시키고 송/수신자가 느슨한 결합을 이룬다.

객체는 다른 객체의 상태를 묻는다는 것은 다른 객체의 상태에 대해 너무 많은 고민을 하고 있다는 것을 의미한다. 메시지가 무엇을 해야 하는지를 중심으로 요청하면 결합도가 낮아지고 설계가 유연해진다.

### 3. 객체 인터페이스

인터페이스의 특징

1.	내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달

2.	인터페이스를 변경하지 않고 내부 구조를 변경해도 사용자에게 영향 無

3.	대상이 변경되더라도 동일한 인터페이스를 제공하면 상호작용 가능

인터페이스는 공개된 인터페이스와 내부 인터페이스로 구분된다.

객체지향 패러다임 안에서는 자기 스스로에게도 메시지를 전송한다.

구현

객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함
객체의 변경에 의한 파급효과를 줄이기 위해 인터페이스와 구현은 분리해야 한다.(캡슐화)

책임이 자율적일수록 적절하게 추상화되며 응집도가 높아지고, 결합도가 낮아지며, 캡슐화가 증진되고, 인터페이스와 구현이 명확히 분리되며, 설계의 유연성과 재사용성이 향상된다.